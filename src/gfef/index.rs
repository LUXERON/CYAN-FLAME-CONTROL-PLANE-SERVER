//! GFEF Index Generation Service
//! 
//! This is the CORE IP of the NULL SPACE AI system.
//! The GFEF index contains spectral signatures that enable:
//! - Predicting which neurons will activate for a given input
//! - Loading only 5% of weights per inference
//! - 19.6× weight reduction (before UAO-QTCAM)
//! 
//! The index is generated by the Control Plane from customer weights,
//! making it NEUNOMY's intellectual property - not the customer's.

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use uuid::Uuid;
use std::collections::HashMap;

/// Spectral signature for a single neuron
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NeuronSignature {
    /// Layer this neuron belongs to
    pub layer_id: u32,
    /// Index within layer
    pub neuron_idx: u32,
    /// L2 energy (receptive field strength)
    pub energy: f32,
    /// Projection onto principal components
    pub projection: Vec<f32>,
    /// FFT-based spectral hash
    pub spectral_hash: Vec<f32>,
}

/// Spectral index for a layer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LayerIndex {
    pub layer_id: u32,
    pub layer_name: String,
    pub num_neurons: u32,
    pub input_dim: u32,
    pub k_components: u32,
    /// Principal components (for projection)
    pub principal_components: Vec<f32>,
    /// Per-neuron signatures
    pub signatures: Vec<NeuronSignature>,
}

/// Complete GFEF index for a model
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GFEFIndex {
    /// Unique index ID
    pub id: Uuid,
    /// Customer who owns the underlying weights
    pub customer_id: Uuid,
    /// Model identifier
    pub model_id: String,
    /// Model name (e.g., "Qwen3-MoE-Coder")
    pub model_name: String,
    /// When index was generated
    pub generated_at: DateTime<Utc>,
    /// Expiration (forces re-generation for updates)
    pub expires_at: Option<DateTime<Utc>>,
    /// Per-layer indices
    pub layers: Vec<LayerIndex>,
    /// Total neurons indexed
    pub total_neurons: u64,
    /// Index configuration
    pub config: IndexConfig,
}

/// Index configuration parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexConfig {
    /// Number of principal components
    pub k_components: u32,
    /// FFT bins for spectral hash
    pub fft_bins: u32,
    /// Target sparsity (0.0 to 1.0)
    pub target_sparsity: f32,
}

impl Default for IndexConfig {
    fn default() -> Self {
        Self {
            k_components: 32,
            fft_bins: 16,
            target_sparsity: 0.95,
        }
    }
}

/// Metadata about a stored index
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexMetadata {
    pub id: Uuid,
    pub customer_id: Uuid,
    pub model_id: String,
    pub model_name: String,
    pub generated_at: DateTime<Utc>,
    pub total_neurons: u64,
    pub num_layers: usize,
    pub index_size_bytes: u64,
}

impl From<&GFEFIndex> for IndexMetadata {
    fn from(index: &GFEFIndex) -> Self {
        Self {
            id: index.id,
            customer_id: index.customer_id,
            model_id: index.model_id.clone(),
            model_name: index.model_name.clone(),
            generated_at: index.generated_at,
            total_neurons: index.total_neurons,
            num_layers: index.layers.len(),
            index_size_bytes: 0, // Set by storage
        }
    }
}

/// GFEF Index Generator
/// 
/// Generates spectral indices from model weights.
/// This runs on the Control Plane, NOT on customer hardware.
pub struct GFEFIndexGenerator {
    config: IndexConfig,
    /// Cache of generated indices
    index_cache: HashMap<String, GFEFIndex>,
}

impl GFEFIndexGenerator {
    pub fn new(config: IndexConfig) -> Self {
        Self {
            config,
            index_cache: HashMap::new(),
        }
    }
    
    /// Generate index from weight data
    /// 
    /// In production, this would:
    /// 1. Receive encrypted weights via VXLAN
    /// 2. Decrypt in secure enclave
    /// 3. Compute truncated SVD per layer
    /// 4. Extract spectral signatures
    /// 5. Store index (customer never sees it)
    pub fn generate_index(
        &mut self,
        customer_id: Uuid,
        model_id: &str,
        model_name: &str,
        weight_data: &WeightData,
    ) -> GFEFIndex {
        let now = Utc::now();
        let id = Uuid::new_v4();
        
        let mut layers = Vec::new();
        let mut total_neurons = 0u64;
        
        for (layer_id, layer_weights) in weight_data.layers.iter().enumerate() {
            let layer_index = self.process_layer(layer_id as u32, layer_weights);
            total_neurons += layer_index.num_neurons as u64;
            layers.push(layer_index);
        }
        
        let index = GFEFIndex {
            id,
            customer_id,
            model_id: model_id.to_string(),
            model_name: model_name.to_string(),
            generated_at: now,
            expires_at: None,
            layers,
            total_neurons,
            config: self.config.clone(),
        };
        
        // Cache for quick access
        self.index_cache.insert(model_id.to_string(), index.clone());

        index
    }

    /// Process a single layer's weights into spectral index
    fn process_layer(&self, layer_id: u32, weights: &LayerWeights) -> LayerIndex {
        let (m, n) = (weights.rows, weights.cols);
        let k = self.config.k_components.min(m).min(n);

        // Compute truncated SVD
        // In production: uses ndarray-linalg or GPU-accelerated SVD
        let (principal_components, projections) = self.truncated_svd(&weights.data, m, n, k);

        // Compute per-neuron signatures
        let signatures: Vec<NeuronSignature> = (0..m)
            .map(|i| {
                let row_start = i as usize * n as usize;
                let row_end = row_start + n as usize;
                let row = &weights.data[row_start..row_end];

                // Energy (L2 norm)
                let energy: f32 = row.iter().map(|x| x * x).sum::<f32>().sqrt();

                // Projection onto PCs
                let proj_start = i as usize * k as usize;
                let proj_end = proj_start + k as usize;
                let projection = projections[proj_start..proj_end].to_vec();

                // Spectral hash via FFT magnitudes
                let spectral_hash = self.compute_spectral_hash(row);

                NeuronSignature {
                    layer_id,
                    neuron_idx: i,
                    energy,
                    projection,
                    spectral_hash,
                }
            })
            .collect();

        LayerIndex {
            layer_id,
            layer_name: weights.name.clone(),
            num_neurons: m,
            input_dim: n,
            k_components: k,
            principal_components,
            signatures,
        }
    }

    /// Truncated SVD using power iteration (O(n²k) instead of O(n³))
    fn truncated_svd(&self, data: &[f32], m: u32, n: u32, k: u32) -> (Vec<f32>, Vec<f32>) {
        let m = m as usize;
        let n = n as usize;
        let k = k as usize;

        // Simplified power iteration for demo
        // Production uses ndarray-linalg SVD
        let mut v = vec![0.0f32; n * k];
        let mut projections = vec![0.0f32; m * k];

        // Initialize V with pseudo-random orthogonal vectors
        for j in 0..k {
            for i in 0..n {
                v[i * k + j] = if (i + j) % 2 == 0 { 1.0 } else { -1.0 };
                v[i * k + j] /= (n as f32).sqrt();
            }
        }

        // Project data onto V
        for i in 0..m {
            for j in 0..k {
                let mut sum = 0.0f32;
                for l in 0..n {
                    sum += data[i * n + l] * v[l * k + j];
                }
                projections[i * k + j] = sum;
            }
        }

        (v, projections)
    }

    /// Compute FFT-based spectral hash
    fn compute_spectral_hash(&self, row: &[f32]) -> Vec<f32> {
        let bins = self.config.fft_bins as usize;
        let n = row.len();
        let mut hash = vec![0.0f32; bins];

        // Simple DFT magnitude bins (production uses FFT)
        for k in 0..bins {
            let freq = k as f32 / bins as f32;
            let mut real = 0.0f32;
            let mut imag = 0.0f32;

            for (i, &x) in row.iter().enumerate() {
                let angle = 2.0 * std::f32::consts::PI * freq * i as f32;
                real += x * angle.cos();
                imag += x * angle.sin();
            }

            hash[k] = (real * real + imag * imag).sqrt() / n as f32;
        }

        // Normalize
        let max_val = hash.iter().cloned().fold(0.0f32, f32::max).max(1e-8);
        for h in &mut hash {
            *h /= max_val;
        }

        hash
    }

    /// Get cached index
    pub fn get_index(&self, model_id: &str) -> Option<&GFEFIndex> {
        self.index_cache.get(model_id)
    }
}

/// Weight data received from customer
#[derive(Debug, Clone)]
pub struct WeightData {
    pub layers: Vec<LayerWeights>,
}

/// Weights for a single layer
#[derive(Debug, Clone)]
pub struct LayerWeights {
    pub name: String,
    pub rows: u32,
    pub cols: u32,
    pub data: Vec<f32>,
}
