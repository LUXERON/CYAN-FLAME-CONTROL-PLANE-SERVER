// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalibrationSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    /// "starter", "professional", "enterprise"
    #[prost(string, tag = "2")]
    pub subscription_tier: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalibrationMatrixUpdate {
    #[prost(message, optional, tag = "1")]
    pub matrix: ::core::option::Option<CalibrationMatrix>,
    #[prost(uint64, tag = "2")]
    pub version: u64,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    /// When the next matrix rotation occurs
    #[prost(int64, tag = "4")]
    pub next_rotation_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCalibrationMatrixRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub subscription_tier: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalibrationMatrix {
    /// 64
    #[prost(uint32, tag = "1")]
    pub rows: u32,
    /// 64
    #[prost(uint32, tag = "2")]
    pub cols: u32,
    /// Compact binary representation (64x64 f64 = 32KB)
    #[prost(bytes = "vec", tag = "3")]
    pub matrix_data: ::prost::alloc::vec::Vec<u8>,
    /// SHA-256 hash for verification
    #[prost(string, tag = "4")]
    pub matrix_hash: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub version: u64,
    #[prost(int64, tag = "6")]
    pub generated_at_ms: i64,
    #[prost(int64, tag = "7")]
    pub expires_at_ms: i64,
    #[prost(message, optional, tag = "8")]
    pub amplification: ::core::option::Option<AmplificationFactors>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AmplificationFactors {
    /// 24,500×
    #[prost(double, tag = "1")]
    pub memory_amplification: f64,
    /// 19.6×
    #[prost(double, tag = "2")]
    pub compression_ratio: f64,
    /// Combined factor
    #[prost(double, tag = "3")]
    pub effective_multiplier: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatrixVersionRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub current_version: u64,
    #[prost(string, tag = "3")]
    pub matrix_hash: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatrixVersionResponse {
    #[prost(bool, tag = "1")]
    pub is_valid: bool,
    #[prost(bool, tag = "2")]
    pub needs_update: bool,
    #[prost(uint64, tag = "3")]
    pub latest_version: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeCalibrationRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
    /// Detected physical GPU
    #[prost(string, tag = "3")]
    pub physical_gpu_type: ::prost::alloc::string::String,
    /// Target GPU to emulate
    #[prost(string, tag = "4")]
    pub target_gpu_type: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeCalibrationUpdate {
    #[prost(message, optional, tag = "1")]
    pub matrix: ::core::option::Option<ComputeCalibrationMatrix>,
    #[prost(uint64, tag = "2")]
    pub version: u64,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    #[prost(int64, tag = "4")]
    pub next_rotation_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetComputeCalibrationRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub physical_gpu_type: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeCalibrationMatrix {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(int64, tag = "2")]
    pub generated_at_ms: i64,
    #[prost(int64, tag = "3")]
    pub expires_at_ms: i64,
    #[prost(string, tag = "4")]
    pub matrix_hash: ::prost::alloc::string::String,
    /// CARTF (Cache-Aware Recursive Tensor Folding) parameters
    #[prost(message, optional, tag = "5")]
    pub cartf: ::core::option::Option<CartfCoefficients>,
    /// GFCE (Galois Field Compute Engine) lookup tables
    #[prost(message, optional, tag = "6")]
    pub gfce: ::core::option::Option<GaloisFieldConfig>,
    /// DBCG (De Bruijn Compute Graph) weights
    #[prost(message, optional, tag = "7")]
    pub dbcg: ::core::option::Option<DeBruijnConfig>,
    /// CHN-CS (Continuous Hopfield Network Scheduler) energy matrix
    #[prost(message, optional, tag = "8")]
    pub hopfield: ::core::option::Option<HopfieldConfig>,
    /// PMCW (Particle Mesh Compute Wave) FFT coefficients
    #[prost(message, optional, tag = "9")]
    pub pmcw: ::core::option::Option<PmeComputeWaveConfig>,
    /// Combined amplification factor
    #[prost(message, optional, tag = "10")]
    pub amplification: ::core::option::Option<ComputeAmplificationFactors>,
}
/// CARTF: Cache-Aware Recursive Tensor Folding (1.8×)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CartfCoefficients {
    /// L1 cache block size
    #[prost(uint32, tag = "1")]
    pub block_size_l1: u32,
    /// L2 cache block size
    #[prost(uint32, tag = "2")]
    pub block_size_l2: u32,
    /// L3 cache block size
    #[prost(uint32, tag = "3")]
    pub block_size_l3: u32,
    /// Folding recursion depth
    #[prost(uint32, tag = "4")]
    pub recursion_depth: u32,
    /// 32x32 folding matrix (8KB)
    #[prost(bytes = "vec", tag = "5")]
    pub folding_coefficients: ::prost::alloc::vec::Vec<u8>,
    /// 1.8×
    #[prost(double, tag = "6")]
    pub theoretical_factor: f64,
}
/// GFCE: Galois Field GF(2^32) Compute Engine (14×)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GaloisFieldConfig {
    /// x^32 + x^7 + x^3 + x^2 + 1 = 0x18D
    #[prost(uint64, tag = "1")]
    pub irreducible_polynomial: u64,
    /// Precomputed multiplication table
    #[prost(bytes = "vec", tag = "2")]
    pub multiplication_lut: ::prost::alloc::vec::Vec<u8>,
    /// Multiplicative inverse table
    #[prost(bytes = "vec", tag = "3")]
    pub inverse_lut: ::prost::alloc::vec::Vec<u8>,
    /// Discrete log table
    #[prost(bytes = "vec", tag = "4")]
    pub log_table: ::prost::alloc::vec::Vec<u8>,
    /// Anti-log table
    #[prost(bytes = "vec", tag = "5")]
    pub antilog_table: ::prost::alloc::vec::Vec<u8>,
    /// 14.0×
    #[prost(double, tag = "6")]
    pub theoretical_factor: f64,
}
/// DBCG: De Bruijn Compute Graph (2.19×)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeBruijnConfig {
    /// De Bruijn graph order (k)
    #[prost(uint32, tag = "1")]
    pub graph_order: u32,
    /// Alphabet size (n)
    #[prost(uint32, tag = "2")]
    pub alphabet_size: u32,
    /// Eulerian path edge weights
    #[prost(bytes = "vec", tag = "3")]
    pub eulerian_weights: ::prost::alloc::vec::Vec<u8>,
    /// Compact adjacency representation
    #[prost(bytes = "vec", tag = "4")]
    pub adjacency_matrix: ::prost::alloc::vec::Vec<u8>,
    /// 2.19×
    #[prost(double, tag = "5")]
    pub theoretical_factor: f64,
}
/// CHN-CS: Continuous Hopfield Network Scheduler (1.45×)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HopfieldConfig {
    /// Number of neurons
    #[prost(uint32, tag = "1")]
    pub neuron_count: u32,
    /// Symmetric weight matrix W
    #[prost(bytes = "vec", tag = "2")]
    pub energy_matrix: ::prost::alloc::vec::Vec<u8>,
    /// Bias vector b
    #[prost(bytes = "vec", tag = "3")]
    pub bias_vector: ::prost::alloc::vec::Vec<u8>,
    /// Temperature for annealing
    #[prost(double, tag = "4")]
    pub temperature: f64,
    /// Energy convergence threshold
    #[prost(double, tag = "5")]
    pub convergence_threshold: f64,
    /// 1.45×
    #[prost(double, tag = "6")]
    pub theoretical_factor: f64,
}
/// PMCW: Particle Mesh Compute Wave (1.45×)
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PmeComputeWaveConfig {
    /// PME grid size (N³)
    #[prost(uint32, tag = "1")]
    pub grid_size: u32,
    /// B-spline interpolation order
    #[prost(uint32, tag = "2")]
    pub spline_order: u32,
    /// Charge spreading coefficients
    #[prost(bytes = "vec", tag = "3")]
    pub charge_spreading_coeffs: ::prost::alloc::vec::Vec<u8>,
    /// Precomputed twiddle factors
    #[prost(bytes = "vec", tag = "4")]
    pub fft_twiddle_factors: ::prost::alloc::vec::Vec<u8>,
    /// Ewald splitting parameter (β)
    #[prost(double, tag = "5")]
    pub ewald_coefficient: f64,
    /// 1.45×
    #[prost(double, tag = "6")]
    pub theoretical_factor: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ComputeAmplificationFactors {
    /// CARTF contribution (1.8×)
    #[prost(double, tag = "1")]
    pub cartf_factor: f64,
    /// Galois Field contribution (14×)
    #[prost(double, tag = "2")]
    pub gfce_factor: f64,
    /// De Bruijn contribution (2.19×)
    #[prost(double, tag = "3")]
    pub dbcg_factor: f64,
    /// Hopfield contribution (1.45×)
    #[prost(double, tag = "4")]
    pub hopfield_factor: f64,
    /// PME contribution (1.45×)
    #[prost(double, tag = "5")]
    pub pmcw_factor: f64,
    /// Theoretical max (116.20×)
    #[prost(double, tag = "6")]
    pub theoretical_combined: f64,
    /// Practical with overhead (29.86×)
    #[prost(double, tag = "7")]
    pub practical_combined: f64,
    /// Orchestration overhead (25.7%)
    #[prost(double, tag = "8")]
    pub overhead_percent: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineConfigRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub physical_gpu_type: ::prost::alloc::string::String,
    /// \["cartf", "gfce", "dbcg", "hopfield", "pmcw"\]
    #[prost(string, repeated, tag = "4")]
    pub enabled_engines: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineConfigResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// Engine name → amplification factor
    #[prost(map = "string, double", tag = "3")]
    pub engine_factors: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
    /// Engine name → enabled status
    #[prost(map = "string, bool", tag = "4")]
    pub engine_enabled: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        bool,
    >,
    /// Combined practical factor
    #[prost(double, tag = "5")]
    pub combined_factor: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcIeCalibrationRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
    /// "gen3", "gen4", "gen5"
    #[prost(string, tag = "3")]
    pub pcie_generation: ::prost::alloc::string::String,
    /// 4, 8, 16
    #[prost(uint32, tag = "4")]
    pub pcie_lanes: u32,
    /// Detected bandwidth in GB/s
    #[prost(uint64, tag = "5")]
    pub current_bandwidth_gbs: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcIeCalibrationUpdate {
    #[prost(message, optional, tag = "1")]
    pub matrix: ::core::option::Option<PcIeCalibrationMatrix>,
    #[prost(uint64, tag = "2")]
    pub version: u64,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    #[prost(int64, tag = "4")]
    pub next_rotation_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPcIeConfigRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcIeCalibrationMatrix {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(int64, tag = "2")]
    pub generated_at_ms: i64,
    #[prost(int64, tag = "3")]
    pub expires_at_ms: i64,
    #[prost(string, tag = "4")]
    pub matrix_hash: ::prost::alloc::string::String,
    /// Predictive prefetch parameters (Hopfield-based)
    #[prost(message, optional, tag = "5")]
    pub prefetch: ::core::option::Option<PrefetchConfig>,
    /// Transfer coalescing parameters (De Bruijn-based)
    #[prost(message, optional, tag = "6")]
    pub coalescing: ::core::option::Option<CoalescingConfig>,
    /// Compression parameters (Galois Field-based)
    #[prost(message, optional, tag = "7")]
    pub compression: ::core::option::Option<PcIeCompressionConfig>,
    /// Amplification factors
    #[prost(message, optional, tag = "8")]
    pub amplification: ::core::option::Option<PcIeAmplificationFactors>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrefetchConfig {
    /// How many transfers to prefetch
    #[prost(uint32, tag = "1")]
    pub prefetch_depth: u32,
    /// Stride pattern for sequential access
    #[prost(uint32, tag = "2")]
    pub prefetch_stride: u32,
    /// Hopfield energy weights for prediction
    #[prost(bytes = "vec", tag = "3")]
    pub prediction_weights: ::prost::alloc::vec::Vec<u8>,
    /// Target prefetch hit rate (95%)
    #[prost(double, tag = "4")]
    pub hit_rate_target: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoalescingConfig {
    /// Minimum transfers to batch
    #[prost(uint32, tag = "1")]
    pub min_batch_size: u32,
    /// Maximum batch size
    #[prost(uint32, tag = "2")]
    pub max_batch_size: u32,
    /// Coalescing timeout in microseconds
    #[prost(uint32, tag = "3")]
    pub timeout_us: u32,
    /// De Bruijn optimal scheduling
    #[prost(bytes = "vec", tag = "4")]
    pub debruijn_schedule: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcIeCompressionConfig {
    #[prost(bool, tag = "1")]
    pub enable_compression: bool,
    /// 0-9
    #[prost(uint32, tag = "2")]
    pub compression_level: u32,
    /// Galois field compression LUT
    #[prost(bytes = "vec", tag = "3")]
    pub galois_lut: ::prost::alloc::vec::Vec<u8>,
    /// Expected compression ratio
    #[prost(double, tag = "4")]
    pub compression_ratio: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PcIeAmplificationFactors {
    /// Prefetch hit rate improvement
    #[prost(double, tag = "1")]
    pub prefetch_factor: f64,
    /// Batch coalescing improvement
    #[prost(double, tag = "2")]
    pub coalescing_factor: f64,
    /// Compression improvement
    #[prost(double, tag = "3")]
    pub compression_factor: f64,
    /// Total PCIe amplification (82×)
    #[prost(double, tag = "4")]
    pub combined_factor: f64,
    /// Physical PCIe bandwidth
    #[prost(double, tag = "5")]
    pub physical_bandwidth_gbs: f64,
    /// Effective bandwidth after amplification
    #[prost(double, tag = "6")]
    pub effective_bandwidth_gbs: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcIeMetricsReport {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    #[prost(uint64, tag = "3")]
    pub bytes_transferred: u64,
    #[prost(uint64, tag = "4")]
    pub transfers_count: u64,
    #[prost(double, tag = "5")]
    pub avg_latency_us: f64,
    #[prost(double, tag = "6")]
    pub prefetch_hit_rate: f64,
    #[prost(double, tag = "7")]
    pub coalescing_efficiency: f64,
    #[prost(double, tag = "8")]
    pub compression_ratio_achieved: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PcIeOptimizationHint {
    #[prost(int64, tag = "1")]
    pub timestamp_ms: i64,
    /// "prefetch", "coalescing", "compression"
    #[prost(string, tag = "2")]
    pub optimization_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub hint_message: ::prost::alloc::string::String,
    #[prost(map = "string, double", tag = "4")]
    pub suggested_params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        f64,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryStatusUpdate {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    #[prost(message, optional, tag = "3")]
    pub gpu_status: ::core::option::Option<GpuMemoryStatus>,
    #[prost(message, optional, tag = "4")]
    pub effective_status: ::core::option::Option<EffectiveMemoryStatus>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuMemoryStatus {
    #[prost(string, tag = "1")]
    pub gpu_name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub total_mb: u64,
    #[prost(uint64, tag = "3")]
    pub used_mb: u64,
    #[prost(uint64, tag = "4")]
    pub free_mb: u64,
    #[prost(float, tag = "5")]
    pub utilization_percent: f32,
    #[prost(float, tag = "6")]
    pub temperature_celsius: f32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EffectiveMemoryStatus {
    #[prost(uint64, tag = "1")]
    pub total_tb: u64,
    #[prost(uint64, tag = "2")]
    pub allocated_tb: u64,
    #[prost(uint64, tag = "3")]
    pub available_tb: u64,
    #[prost(double, tag = "4")]
    pub amplification_factor: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TelemetryAck {
    #[prost(bool, tag = "1")]
    pub received: bool,
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkCapacityRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub include_all_nodes: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkCapacityUpdate {
    #[prost(int64, tag = "1")]
    pub timestamp_ms: i64,
    #[prost(uint32, tag = "2")]
    pub total_nodes: u32,
    #[prost(uint32, tag = "3")]
    pub active_nodes: u32,
    #[prost(message, optional, tag = "4")]
    pub metrics: ::core::option::Option<NetworkCapacityMetrics>,
    #[prost(message, repeated, tag = "5")]
    pub nodes: ::prost::alloc::vec::Vec<NodeCapacity>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkCapacityMetrics {
    #[prost(uint64, tag = "1")]
    pub total_physical_gb: u64,
    #[prost(uint64, tag = "2")]
    pub total_effective_tb: u64,
    #[prost(uint64, tag = "3")]
    pub allocated_effective_tb: u64,
    #[prost(uint64, tag = "4")]
    pub available_effective_tb: u64,
    #[prost(double, tag = "5")]
    pub network_utilization_percent: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeCapacity {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub node_address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub physical_gb: u64,
    #[prost(uint64, tag = "4")]
    pub effective_tb: u64,
    #[prost(uint64, tag = "5")]
    pub allocated_tb: u64,
    #[prost(bool, tag = "6")]
    pub is_healthy: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthMetrics {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    #[prost(float, tag = "3")]
    pub cpu_percent: f32,
    #[prost(float, tag = "4")]
    pub memory_percent: f32,
    #[prost(float, tag = "5")]
    pub gpu_utilization: f32,
    #[prost(uint64, tag = "6")]
    pub uptime_seconds: u64,
    #[prost(uint32, tag = "7")]
    pub active_connections: u32,
    #[prost(uint64, tag = "8")]
    pub requests_processed: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthAck {
    #[prost(bool, tag = "1")]
    pub received: bool,
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub requested_tb: u64,
    /// "model_loading", "inference", "training"
    #[prost(string, tag = "4")]
    pub purpose: ::prost::alloc::string::String,
    /// 0 = indefinite
    #[prost(int64, tag = "5")]
    pub duration_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub allocation_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub allocated_tb: u64,
    #[prost(string, tag = "4")]
    pub assigned_node: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub expires_at_ms: i64,
    #[prost(string, tag = "6")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FreeMemoryRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub allocation_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FreeMemoryResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, tag = "2")]
    pub freed_tb: u64,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryRoutingRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub required_tb: u64,
    #[prost(string, tag = "3")]
    pub preferred_region: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub low_latency: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryRoutingResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(string, tag = "2")]
    pub optimal_node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub node_address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub available_tb: u64,
    #[prost(float, tag = "5")]
    pub latency_ms: f32,
    #[prost(message, repeated, tag = "6")]
    pub alternatives: ::prost::alloc::vec::Vec<AlternativeNode>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlternativeNode {
    #[prost(string, tag = "1")]
    pub node_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub available_tb: u64,
    #[prost(float, tag = "4")]
    pub latency_ms: f32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationStatusRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    /// Optional - if empty, returns all allocations
    #[prost(string, tag = "2")]
    pub allocation_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationStatusResponse {
    #[prost(message, repeated, tag = "1")]
    pub allocations: ::prost::alloc::vec::Vec<AllocationInfo>,
    #[prost(uint64, tag = "2")]
    pub total_allocated_tb: u64,
    #[prost(uint64, tag = "3")]
    pub quota_tb: u64,
    #[prost(uint64, tag = "4")]
    pub remaining_quota_tb: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationInfo {
    #[prost(string, tag = "1")]
    pub allocation_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub size_tb: u64,
    #[prost(string, tag = "3")]
    pub purpose: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub created_at_ms: i64,
    #[prost(int64, tag = "5")]
    pub expires_at_ms: i64,
    #[prost(string, tag = "6")]
    pub node_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {
    #[prost(bool, tag = "1")]
    pub healthy: bool,
    /// "SERVING", "NOT_SERVING", "UNKNOWN"
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
    #[prost(map = "string, string", tag = "4")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub download_url: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub checksum: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub force: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeProgress {
    /// "DOWNLOADING", "VERIFYING", "INSTALLING", "RESTARTING", "COMPLETE"
    #[prost(string, tag = "1")]
    pub stage: ::prost::alloc::string::String,
    #[prost(float, tag = "2")]
    pub progress_percent: f32,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub success: bool,
    #[prost(string, tag = "5")]
    pub error: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemInfoRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemInfoResponse {
    #[prost(string, tag = "1")]
    pub agent_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub os: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub arch: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub cpu_cores: u32,
    #[prost(uint64, tag = "5")]
    pub total_memory_gb: u64,
    #[prost(message, optional, tag = "6")]
    pub gpu: ::core::option::Option<GpuInfo>,
    #[prost(int64, tag = "7")]
    pub started_at_ms: i64,
    #[prost(uint64, tag = "8")]
    pub uptime_seconds: u64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub driver_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub cuda_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub memory_mb: u64,
    #[prost(uint32, tag = "5")]
    pub compute_capability_major: u32,
    #[prost(uint32, tag = "6")]
    pub compute_capability_minor: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuRegistrationRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub detected_gpu: ::core::option::Option<DetectedGpuInfo>,
    /// Target GPU to emulate (customer selected)
    #[prost(enumeration = "TargetGpuType", tag = "4")]
    pub target_gpu: i32,
    /// Custom target specifications (if target_gpu = TARGET_CUSTOM)
    #[prost(message, optional, tag = "5")]
    pub custom_target: ::core::option::Option<CustomTargetSpecs>,
}
/// Custom target specifications for advanced users
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomTargetSpecs {
    /// Target VRAM in GB
    #[prost(uint64, tag = "1")]
    pub target_vram_gb: u64,
    /// Target bandwidth in GB/s
    #[prost(double, tag = "2")]
    pub target_memory_bandwidth_gbs: f64,
    /// Target FP16 TFLOPS
    #[prost(double, tag = "3")]
    pub target_fp16_tflops: f64,
    /// Target FP8 TFLOPS
    #[prost(double, tag = "4")]
    pub target_fp8_tflops: f64,
    /// Require FP8 emulation
    #[prost(bool, tag = "5")]
    pub require_fp8: bool,
    /// Require sparsity support
    #[prost(bool, tag = "6")]
    pub require_sparsity: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetectedGpuInfo {
    /// GPU identification
    ///
    /// Full GPU name (e.g., "NVIDIA GeForce RTX 4090")
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// PCI device ID for exact identification
    #[prost(string, tag = "2")]
    pub pci_device_id: ::prost::alloc::string::String,
    /// GPU driver version
    #[prost(string, tag = "3")]
    pub driver_version: ::prost::alloc::string::String,
    /// Compute capabilities
    ///
    /// Compute capability major version
    #[prost(uint32, tag = "4")]
    pub compute_capability_major: u32,
    /// Compute capability minor version
    #[prost(uint32, tag = "5")]
    pub compute_capability_minor: u32,
    /// Memory specifications
    ///
    /// Total VRAM in MB
    #[prost(uint64, tag = "6")]
    pub memory_total_mb: u64,
    /// Memory bandwidth in GB/s
    #[prost(uint64, tag = "7")]
    pub memory_bandwidth_gbs: u64,
    /// Compute specifications (raw TFLOPS)
    ///
    /// FP16 Tensor TFLOPS
    #[prost(double, tag = "8")]
    pub fp16_tflops: f64,
    /// FP32 TFLOPS
    #[prost(double, tag = "9")]
    pub fp32_tflops: f64,
    /// TF32 Tensor TFLOPS (NVIDIA only)
    #[prost(double, tag = "10")]
    pub tf32_tflops: f64,
    /// FP8 Tensor TFLOPS (Hopper+/Ada+)
    #[prost(double, tag = "11")]
    pub fp8_tflops: f64,
    /// Architecture info
    ///
    /// "Volta", "Ampere", "Hopper", "Ada", "CDNA1", etc.
    #[prost(string, tag = "12")]
    pub architecture: ::prost::alloc::string::String,
    /// "NVIDIA", "AMD"
    #[prost(string, tag = "13")]
    pub vendor: ::prost::alloc::string::String,
    /// Native FP8 support
    #[prost(bool, tag = "14")]
    pub supports_fp8: bool,
    /// Hardware sparsity support
    #[prost(bool, tag = "15")]
    pub supports_sparsity: bool,
    /// NVLink support for multi-GPU
    #[prost(bool, tag = "16")]
    pub supports_nvlink: bool,
    /// ROCm/CUDA info
    ///
    /// CUDA version (NVIDIA)
    #[prost(string, tag = "17")]
    pub cuda_version: ::prost::alloc::string::String,
    /// ROCm version (AMD)
    #[prost(string, tag = "18")]
    pub rocm_version: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuRegistrationResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// Detected baseline GPU type (source GPU)
    #[prost(enumeration = "BaselineGpuType", tag = "3")]
    pub detected_baseline: i32,
    /// Human-readable source GPU name
    #[prost(string, tag = "4")]
    pub baseline_name: ::prost::alloc::string::String,
    /// Selected target GPU (what customer wants to emulate)
    #[prost(enumeration = "TargetGpuType", tag = "5")]
    pub target_gpu: i32,
    /// Human-readable target GPU name
    #[prost(string, tag = "6")]
    pub target_name: ::prost::alloc::string::String,
    /// Tier configuration based on source→target path
    #[prost(message, optional, tag = "7")]
    pub tier_config: ::core::option::Option<GpuBasedTierConfig>,
    /// Amplification targets to reach selected target
    #[prost(message, optional, tag = "8")]
    pub amplification_targets: ::core::option::Option<AmplificationTargets>,
    /// Client certificate fingerprint (for mTLS binding)
    #[prost(string, tag = "9")]
    pub certificate_binding: ::prost::alloc::string::String,
    /// Cost estimation for this GPU transformation
    #[prost(message, optional, tag = "10")]
    pub cost_estimate: ::core::option::Option<CostEstimate>,
}
/// Cost estimation for GPU amplification
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CostEstimate {
    /// Estimated hourly cost in USD
    #[prost(double, tag = "1")]
    pub hourly_rate_usd: f64,
    /// Estimated daily cost
    #[prost(double, tag = "2")]
    pub daily_rate_usd: f64,
    /// Estimated monthly cost
    #[prost(double, tag = "3")]
    pub monthly_rate_usd: f64,
    /// "economy", "standard", "premium", "enterprise"
    #[prost(string, tag = "4")]
    pub pricing_tier: ::prost::alloc::string::String,
    /// Total amplification (e.g., 3.0×)
    #[prost(double, tag = "5")]
    pub amplification_factor: f64,
    /// Human-readable breakdown
    #[prost(string, tag = "6")]
    pub cost_breakdown: ::prost::alloc::string::String,
}
/// GPU-based tier configuration
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuBasedTierConfig {
    /// "legacy", "workhorse", "inference_pro", etc.
    #[prost(string, tag = "1")]
    pub tier_name: ::prost::alloc::string::String,
    /// Memory amplification
    ///
    /// e.g., 3.7× for V100→H100
    #[prost(double, tag = "2")]
    pub memory_bandwidth_amplification: f64,
    /// Effective memory capacity multiplier
    #[prost(double, tag = "3")]
    pub effective_memory_multiplier: f64,
    /// TFLOPS amplification
    ///
    /// e.g., 7.9× for V100→H100
    #[prost(double, tag = "4")]
    pub tflops_amplification_target: f64,
    /// Pricing factors
    ///
    /// Base price multiplier for this GPU tier
    #[prost(double, tag = "5")]
    pub pricing_multiplier: f64,
    /// "economy", "standard", "premium"
    #[prost(string, tag = "6")]
    pub pricing_tier: ::prost::alloc::string::String,
    /// Limits
    ///
    /// Maximum effective memory in TB
    #[prost(uint64, tag = "7")]
    pub max_effective_memory_tb: u64,
    /// Max concurrent sessions
    #[prost(uint32, tag = "8")]
    pub max_concurrent_sessions: u32,
    /// Rate limit (0 = unlimited)
    #[prost(uint32, tag = "9")]
    pub rate_limit_per_minute: u32,
    /// Strategy recommendations
    ///
    /// \["aggressive_quantization", "sparsity", etc.\]
    #[prost(string, repeated, tag = "10")]
    pub optimization_strategies: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Amplification targets to reach H100-equivalent performance
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AmplificationTargets {
    /// Memory bandwidth amplification needed
    ///
    /// e.g., 3.7× for V100
    #[prost(double, tag = "1")]
    pub memory_bandwidth_multiplier: f64,
    /// Client's current bandwidth
    #[prost(double, tag = "2")]
    pub current_bandwidth_gbs: f64,
    /// H100 target (3,350 GB/s)
    #[prost(double, tag = "3")]
    pub target_bandwidth_gbs: f64,
    /// TFLOPS amplification needed
    ///
    /// e.g., 7.9× for V100
    #[prost(double, tag = "4")]
    pub tflops_multiplier: f64,
    /// Client's current TFLOPS
    #[prost(double, tag = "5")]
    pub current_fp16_tflops: f64,
    /// H100 target (989 TFLOPS)
    #[prost(double, tag = "6")]
    pub target_fp16_tflops: f64,
    /// VRAM capacity comparison
    #[prost(uint64, tag = "7")]
    pub current_vram_gb: u64,
    /// H100 target (80 GB)
    #[prost(uint64, tag = "8")]
    pub target_vram_gb: u64,
    #[prost(double, tag = "9")]
    pub vram_multiplier: f64,
    /// Feature gap analysis
    ///
    /// True if GPU doesn't have native FP8
    #[prost(bool, tag = "10")]
    pub needs_fp8_emulation: bool,
    /// True if GPU doesn't have hardware sparsity
    #[prost(bool, tag = "11")]
    pub needs_sparsity_software: bool,
    /// True if NVLink available
    #[prost(bool, tag = "12")]
    pub has_nvlink: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuTierRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GpuTierResponse {
    #[prost(enumeration = "BaselineGpuType", tag = "1")]
    pub current_baseline: i32,
    #[prost(message, optional, tag = "2")]
    pub tier_config: ::core::option::Option<GpuBasedTierConfig>,
    #[prost(message, optional, tag = "3")]
    pub amplification_targets: ::core::option::Option<AmplificationTargets>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSupportedGpusRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSupportedGpusResponse {
    #[prost(message, repeated, tag = "1")]
    pub supported_gpus: ::prost::alloc::vec::Vec<SupportedGpuInfo>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupportedGpuInfo {
    #[prost(enumeration = "BaselineGpuType", tag = "1")]
    pub gpu_type: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub architecture: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub vendor: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub vram_gb: u64,
    #[prost(double, tag = "6")]
    pub memory_bandwidth_gbs: f64,
    #[prost(double, tag = "7")]
    pub fp16_tflops: f64,
    #[prost(string, tag = "8")]
    pub pricing_tier: ::prost::alloc::string::String,
    #[prost(double, tag = "9")]
    pub tflops_amplification_to_h100: f64,
    #[prost(double, tag = "10")]
    pub bandwidth_amplification_to_h100: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub org_id: ::prost::alloc::string::String,
    /// e.g., "customer-001.cyanflame.local"
    #[prost(string, tag = "3")]
    pub common_name: ::prost::alloc::string::String,
    /// Additional DNS SANs
    #[prost(string, repeated, tag = "4")]
    pub dns_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Requested validity period
    #[prost(uint32, tag = "5")]
    pub validity_days: u32,
    /// Optional: Customer-provided CSR
    #[prost(string, tag = "6")]
    pub csr_pem: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// Certificate chain
    ///
    /// Issued certificate
    #[prost(string, tag = "3")]
    pub certificate_pem: ::prost::alloc::string::String,
    /// Full chain (cert + intermediate + root)
    #[prost(string, tag = "4")]
    pub certificate_chain_pem: ::prost::alloc::string::String,
    /// Private key (only if CSR not provided)
    #[prost(string, tag = "5")]
    pub private_key_pem: ::prost::alloc::string::String,
    /// Certificate metadata
    #[prost(string, tag = "6")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub fingerprint_sha256: ::prost::alloc::string::String,
    #[prost(int64, tag = "8")]
    pub issued_at_ms: i64,
    #[prost(int64, tag = "9")]
    pub expires_at_ms: i64,
    /// Binding info
    ///
    /// API key this cert is bound to
    #[prost(string, tag = "10")]
    pub bound_api_key_hash: ::prost::alloc::string::String,
    /// GPU type this cert is bound to
    #[prost(enumeration = "BaselineGpuType", tag = "11")]
    pub bound_gpu_type: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenewCertificateRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
    /// Current certificate to renew
    #[prost(string, tag = "2")]
    pub old_certificate_pem: ::prost::alloc::string::String,
    /// New validity period
    #[prost(uint32, tag = "3")]
    pub validity_days: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeCertificateRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
    /// Certificate to revoke
    #[prost(string, tag = "2")]
    pub certificate_pem: ::prost::alloc::string::String,
    /// Alternative: revoke by serial
    #[prost(string, tag = "3")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(enumeration = "RevocationReason", tag = "4")]
    pub reason: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RevokeCertificateResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub serial_number: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub revoked_at_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateStatusRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
    /// Check by serial number
    #[prost(string, tag = "2")]
    pub serial_number: ::prost::alloc::string::String,
    /// Or by fingerprint
    #[prost(string, tag = "3")]
    pub fingerprint_sha256: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertificateStatusResponse {
    #[prost(bool, tag = "1")]
    pub found: bool,
    #[prost(string, tag = "2")]
    pub serial_number: ::prost::alloc::string::String,
    /// "valid", "expired", "revoked"
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub issued_at_ms: i64,
    #[prost(int64, tag = "5")]
    pub expires_at_ms: i64,
    /// 0 if not revoked
    #[prost(int64, tag = "6")]
    pub revoked_at_ms: i64,
    #[prost(enumeration = "RevocationReason", tag = "7")]
    pub revocation_reason: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrlRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CrlResponse {
    /// DER-encoded CRL
    #[prost(bytes = "vec", tag = "1")]
    pub crl_der: ::prost::alloc::vec::Vec<u8>,
    /// PEM-encoded CRL
    #[prost(string, tag = "2")]
    pub crl_pem: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub this_update_ms: i64,
    #[prost(int64, tag = "4")]
    pub next_update_ms: i64,
    #[prost(uint32, tag = "5")]
    pub revoked_count: u32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OcspRequest {
    /// DER-encoded OCSP request
    #[prost(bytes = "vec", tag = "1")]
    pub ocsp_request_der: ::prost::alloc::vec::Vec<u8>,
    /// Alternative: check by serial
    #[prost(string, tag = "2")]
    pub serial_number: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OcspResponse {
    /// DER-encoded OCSP response
    #[prost(bytes = "vec", tag = "1")]
    pub ocsp_response_der: ::prost::alloc::vec::Vec<u8>,
    /// "good", "revoked", "unknown"
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub this_update_ms: i64,
    #[prost(int64, tag = "4")]
    pub next_update_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartRequest {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub graceful: bool,
    #[prost(int32, tag = "3")]
    pub delay_seconds: i32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartResponse {
    #[prost(bool, tag = "1")]
    pub accepted: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub restart_at_ms: i64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashboardMetricsRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
    /// Requested refresh interval
    #[prost(uint32, tag = "2")]
    pub refresh_interval_ms: u32,
    /// Include per-agent metrics
    #[prost(bool, tag = "3")]
    pub include_agent_details: bool,
    /// Include network traffic stats
    #[prost(bool, tag = "4")]
    pub include_network_stats: bool,
    /// Include certificate statistics
    #[prost(bool, tag = "5")]
    pub include_cert_stats: bool,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DashboardMetricsUpdate {
    #[prost(int64, tag = "1")]
    pub timestamp_ms: i64,
    /// System metrics
    #[prost(float, tag = "2")]
    pub cpu_usage_percent: f32,
    #[prost(float, tag = "3")]
    pub memory_usage_percent: f32,
    #[prost(float, tag = "4")]
    pub memory_total_gb: f32,
    #[prost(uint64, tag = "5")]
    pub uptime_secs: u64,
    /// Network metrics
    #[prost(uint64, tag = "6")]
    pub total_connections: u64,
    #[prost(uint64, tag = "7")]
    pub active_connections: u64,
    #[prost(uint64, tag = "8")]
    pub bytes_in: u64,
    #[prost(uint64, tag = "9")]
    pub bytes_out: u64,
    #[prost(double, tag = "10")]
    pub requests_per_sec: f64,
    #[prost(double, tag = "11")]
    pub avg_latency_ms: f64,
    /// Calibration metrics
    #[prost(uint64, tag = "12")]
    pub calibration_requests_total: u64,
    #[prost(uint64, tag = "13")]
    pub gpu_registrations_total: u64,
    /// Certificate metrics
    #[prost(uint64, tag = "14")]
    pub certificates_issued: u64,
    #[prost(uint64, tag = "15")]
    pub certificates_active: u64,
    #[prost(uint64, tag = "16")]
    pub certificates_revoked: u64,
    #[prost(uint64, tag = "17")]
    pub certificates_expired: u64,
    /// Connected agents summary
    #[prost(uint32, tag = "18")]
    pub total_agents: u32,
    #[prost(uint32, tag = "19")]
    pub agents_by_tier_free: u32,
    #[prost(uint32, tag = "20")]
    pub agents_by_tier_starter: u32,
    #[prost(uint32, tag = "21")]
    pub agents_by_tier_pro: u32,
    #[prost(uint32, tag = "22")]
    pub agents_by_tier_enterprise: u32,
    /// Top GPUs connected
    #[prost(message, repeated, tag = "23")]
    pub top_agents: ::prost::alloc::vec::Vec<ConnectedAgentSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectedAgentSummary {
    #[prost(string, tag = "1")]
    pub agent_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gpu_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub gpu_name: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub vram_gb: f32,
    #[prost(float, tag = "5")]
    pub tflops: f32,
    #[prost(string, tag = "6")]
    pub amplification_tier: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub target_gpu: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "9")]
    pub connected_at_ms: i64,
    #[prost(double, tag = "10")]
    pub hourly_rate_usd: f64,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectedAgentsRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
    /// Max agents to return (default: 100)
    #[prost(uint32, tag = "2")]
    pub limit: u32,
    /// Filter by tier (optional)
    #[prost(string, tag = "3")]
    pub filter_tier: ::prost::alloc::string::String,
    /// Filter by GPU type (optional)
    #[prost(string, tag = "4")]
    pub filter_gpu_type: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectedAgentsResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub total_count: u32,
    #[prost(message, repeated, tag = "4")]
    pub agents: ::prost::alloc::vec::Vec<ConnectedAgentSummary>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemSummaryRequest {
    #[prost(string, tag = "1")]
    pub api_key: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemSummaryResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
    /// Server info
    #[prost(string, tag = "3")]
    pub server_version: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub started_at_ms: i64,
    #[prost(uint64, tag = "5")]
    pub uptime_secs: u64,
    /// Capacity summary
    #[prost(uint32, tag = "6")]
    pub total_agents_connected: u32,
    #[prost(double, tag = "7")]
    pub total_tflops_capacity: f64,
    #[prost(double, tag = "8")]
    pub total_vram_capacity_gb: f64,
    #[prost(double, tag = "9")]
    pub total_amplified_tflops: f64,
    #[prost(double, tag = "10")]
    pub total_amplified_vram_gb: f64,
    /// Revenue metrics (for enterprise dashboard)
    #[prost(double, tag = "11")]
    pub hourly_revenue_usd: f64,
    #[prost(double, tag = "12")]
    pub daily_revenue_estimate_usd: f64,
    #[prost(double, tag = "13")]
    pub monthly_revenue_estimate_usd: f64,
    /// Health status
    ///
    /// "healthy", "degraded", "critical"
    #[prost(string, tag = "14")]
    pub cluster_health: ::prost::alloc::string::String,
    #[prost(uint32, tag = "15")]
    pub healthy_nodes: u32,
    #[prost(uint32, tag = "16")]
    pub unhealthy_nodes: u32,
}
/// Supported baseline GPU types for tiered pricing
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BaselineGpuType {
    GpuUnknown = 0,
    /// NVIDIA Data Center GPUs
    ///
    /// Volta - Legacy tier (CC 7.0)
    NvidiaV100 = 1,
    /// Ampere - Workhorse tier (CC 8.0)
    NvidiaA100 = 2,
    /// Hopper - Target benchmark (CC 9.0)
    NvidiaH100 = 3,
    /// Enhanced Hopper (CC 9.0)
    NvidiaH200 = 4,
    /// Ada - Inference Pro tier (CC 8.9)
    NvidiaL40s = 5,
    /// Ampere - Entry Inference tier (CC 8.6)
    NvidiaA10 = 6,
    /// Ampere - Mid Inference tier (CC 8.0)
    NvidiaA30 = 7,
    /// Ampere - Workstation tier (CC 8.6)
    NvidiaA40 = 8,
    /// Turing - Budget Inference tier (CC 7.5)
    NvidiaTeslaT4 = 9,
    /// NVIDIA Consumer GPUs - Ada Lovelace
    ///
    /// Ada - Consumer Pro tier (CC 8.9)
    NvidiaRtx4090 = 10,
    /// Ada - Consumer tier (CC 8.9)
    NvidiaRtx4080 = 11,
    /// Ada - Mid-range tier (CC 8.9)
    NvidiaRtx4070Ti = 12,
    /// NVIDIA Consumer GPUs - Blackwell
    ///
    /// Blackwell - Consumer Premium (CC 10.0)
    NvidiaRtx5090 = 13,
    /// Blackwell - Consumer Pro (CC 10.0)
    NvidiaRtx5080 = 14,
    /// NVIDIA Legacy Consumer GPUs - Ampere
    ///
    /// Ampere - Legacy Consumer (CC 8.6)
    NvidiaRtx3090 = 15,
    /// Ampere - Legacy Consumer Pro (CC 8.6)
    NvidiaRtx3090Ti = 16,
    /// Ampere - Legacy Mid-range (CC 8.6)
    NvidiaRtx3080 = 17,
    /// AMD Instinct Data Center GPUs
    ///
    /// CDNA 1 - AMD Legacy tier
    AmdMi100 = 20,
    /// CDNA 2 - AMD Workhorse tier
    AmdMi250 = 21,
    /// CDNA 3 - AMD Flagship tier
    AmdMi300x = 22,
    /// CDNA 3+ - AMD Ultra tier
    AmdMi325x = 23,
    /// AMD Consumer GPUs - RDNA 3
    ///
    /// RDNA 3 - AMD Consumer Pro
    AmdRx7900Xtx = 25,
    /// RDNA 3 - AMD Consumer
    AmdRx7900Xt = 26,
}
impl BaselineGpuType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GpuUnknown => "GPU_UNKNOWN",
            Self::NvidiaV100 => "NVIDIA_V100",
            Self::NvidiaA100 => "NVIDIA_A100",
            Self::NvidiaH100 => "NVIDIA_H100",
            Self::NvidiaH200 => "NVIDIA_H200",
            Self::NvidiaL40s => "NVIDIA_L40S",
            Self::NvidiaA10 => "NVIDIA_A10",
            Self::NvidiaA30 => "NVIDIA_A30",
            Self::NvidiaA40 => "NVIDIA_A40",
            Self::NvidiaTeslaT4 => "NVIDIA_TESLA_T4",
            Self::NvidiaRtx4090 => "NVIDIA_RTX_4090",
            Self::NvidiaRtx4080 => "NVIDIA_RTX_4080",
            Self::NvidiaRtx4070Ti => "NVIDIA_RTX_4070_TI",
            Self::NvidiaRtx5090 => "NVIDIA_RTX_5090",
            Self::NvidiaRtx5080 => "NVIDIA_RTX_5080",
            Self::NvidiaRtx3090 => "NVIDIA_RTX_3090",
            Self::NvidiaRtx3090Ti => "NVIDIA_RTX_3090_TI",
            Self::NvidiaRtx3080 => "NVIDIA_RTX_3080",
            Self::AmdMi100 => "AMD_MI100",
            Self::AmdMi250 => "AMD_MI250",
            Self::AmdMi300x => "AMD_MI300X",
            Self::AmdMi325x => "AMD_MI325X",
            Self::AmdRx7900Xtx => "AMD_RX_7900_XTX",
            Self::AmdRx7900Xt => "AMD_RX_7900_XT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GPU_UNKNOWN" => Some(Self::GpuUnknown),
            "NVIDIA_V100" => Some(Self::NvidiaV100),
            "NVIDIA_A100" => Some(Self::NvidiaA100),
            "NVIDIA_H100" => Some(Self::NvidiaH100),
            "NVIDIA_H200" => Some(Self::NvidiaH200),
            "NVIDIA_L40S" => Some(Self::NvidiaL40s),
            "NVIDIA_A10" => Some(Self::NvidiaA10),
            "NVIDIA_A30" => Some(Self::NvidiaA30),
            "NVIDIA_A40" => Some(Self::NvidiaA40),
            "NVIDIA_TESLA_T4" => Some(Self::NvidiaTeslaT4),
            "NVIDIA_RTX_4090" => Some(Self::NvidiaRtx4090),
            "NVIDIA_RTX_4080" => Some(Self::NvidiaRtx4080),
            "NVIDIA_RTX_4070_TI" => Some(Self::NvidiaRtx4070Ti),
            "NVIDIA_RTX_5090" => Some(Self::NvidiaRtx5090),
            "NVIDIA_RTX_5080" => Some(Self::NvidiaRtx5080),
            "NVIDIA_RTX_3090" => Some(Self::NvidiaRtx3090),
            "NVIDIA_RTX_3090_TI" => Some(Self::NvidiaRtx3090Ti),
            "NVIDIA_RTX_3080" => Some(Self::NvidiaRtx3080),
            "AMD_MI100" => Some(Self::AmdMi100),
            "AMD_MI250" => Some(Self::AmdMi250),
            "AMD_MI300X" => Some(Self::AmdMi300x),
            "AMD_MI325X" => Some(Self::AmdMi325x),
            "AMD_RX_7900_XTX" => Some(Self::AmdRx7900Xtx),
            "AMD_RX_7900_XT" => Some(Self::AmdRx7900Xt),
            _ => None,
        }
    }
}
/// Target GPU types that can be emulated
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TargetGpuType {
    TargetGpuUnknown = 0,
    /// NVIDIA H100 80GB HBM3 - Default target
    TargetH100 = 1,
    /// NVIDIA H200 141GB HBM3e
    TargetH200 = 2,
    /// AMD MI300X 192GB HBM3
    TargetMi300x = 3,
    /// NVIDIA A100 80GB HBM2e
    TargetA100 = 4,
    /// NVIDIA L40S 48GB GDDR6
    TargetL40s = 5,
    /// Custom target specifications
    TargetCustom = 99,
}
impl TargetGpuType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TargetGpuUnknown => "TARGET_GPU_UNKNOWN",
            Self::TargetH100 => "TARGET_H100",
            Self::TargetH200 => "TARGET_H200",
            Self::TargetMi300x => "TARGET_MI300X",
            Self::TargetA100 => "TARGET_A100",
            Self::TargetL40s => "TARGET_L40S",
            Self::TargetCustom => "TARGET_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_GPU_UNKNOWN" => Some(Self::TargetGpuUnknown),
            "TARGET_H100" => Some(Self::TargetH100),
            "TARGET_H200" => Some(Self::TargetH200),
            "TARGET_MI300X" => Some(Self::TargetMi300x),
            "TARGET_A100" => Some(Self::TargetA100),
            "TARGET_L40S" => Some(Self::TargetL40s),
            "TARGET_CUSTOM" => Some(Self::TargetCustom),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RevocationReason {
    RevocationUnspecified = 0,
    RevocationKeyCompromise = 1,
    RevocationCaCompromise = 2,
    RevocationAffiliationChanged = 3,
    RevocationSuperseded = 4,
    RevocationCessationOfOperation = 5,
    RevocationCertificateHold = 6,
    RevocationPrivilegeWithdrawn = 7,
}
impl RevocationReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RevocationUnspecified => "REVOCATION_UNSPECIFIED",
            Self::RevocationKeyCompromise => "REVOCATION_KEY_COMPROMISE",
            Self::RevocationCaCompromise => "REVOCATION_CA_COMPROMISE",
            Self::RevocationAffiliationChanged => "REVOCATION_AFFILIATION_CHANGED",
            Self::RevocationSuperseded => "REVOCATION_SUPERSEDED",
            Self::RevocationCessationOfOperation => "REVOCATION_CESSATION_OF_OPERATION",
            Self::RevocationCertificateHold => "REVOCATION_CERTIFICATE_HOLD",
            Self::RevocationPrivilegeWithdrawn => "REVOCATION_PRIVILEGE_WITHDRAWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REVOCATION_UNSPECIFIED" => Some(Self::RevocationUnspecified),
            "REVOCATION_KEY_COMPROMISE" => Some(Self::RevocationKeyCompromise),
            "REVOCATION_CA_COMPROMISE" => Some(Self::RevocationCaCompromise),
            "REVOCATION_AFFILIATION_CHANGED" => Some(Self::RevocationAffiliationChanged),
            "REVOCATION_SUPERSEDED" => Some(Self::RevocationSuperseded),
            "REVOCATION_CESSATION_OF_OPERATION" => {
                Some(Self::RevocationCessationOfOperation)
            }
            "REVOCATION_CERTIFICATE_HOLD" => Some(Self::RevocationCertificateHold),
            "REVOCATION_PRIVILEGE_WITHDRAWN" => Some(Self::RevocationPrivilegeWithdrawn),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod calibration_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct CalibrationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CalibrationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CalibrationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CalibrationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CalibrationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to calibration matrix updates (streaming - rotates every 60s)
        pub async fn subscribe_calibration_matrix(
            &mut self,
            request: impl tonic::IntoRequest<super::CalibrationSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::CalibrationMatrixUpdate>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CalibrationService/SubscribeCalibrationMatrix",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CalibrationService",
                        "SubscribeCalibrationMatrix",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get current calibration matrix (one-shot for initial sync)
        pub async fn get_calibration_matrix(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCalibrationMatrixRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalibrationMatrix>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CalibrationService/GetCalibrationMatrix",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CalibrationService",
                        "GetCalibrationMatrix",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Validate agent's current matrix version
        pub async fn validate_matrix_version(
            &mut self,
            request: impl tonic::IntoRequest<super::MatrixVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MatrixVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CalibrationService/ValidateMatrixVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CalibrationService",
                        "ValidateMatrixVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod compute_calibration_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ComputeCalibrationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ComputeCalibrationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ComputeCalibrationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ComputeCalibrationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ComputeCalibrationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to compute calibration updates (streaming - rotates every 60s)
        pub async fn subscribe_compute_calibration(
            &mut self,
            request: impl tonic::IntoRequest<super::ComputeCalibrationRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ComputeCalibrationUpdate>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.ComputeCalibrationService/SubscribeComputeCalibration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.ComputeCalibrationService",
                        "SubscribeComputeCalibration",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get current compute calibration (one-shot)
        pub async fn get_compute_calibration(
            &mut self,
            request: impl tonic::IntoRequest<super::GetComputeCalibrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeCalibrationMatrix>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.ComputeCalibrationService/GetComputeCalibration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.ComputeCalibrationService",
                        "GetComputeCalibration",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get GPU-specific engine configuration
        pub async fn get_engine_config(
            &mut self,
            request: impl tonic::IntoRequest<super::EngineConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EngineConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.ComputeCalibrationService/GetEngineConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.ComputeCalibrationService",
                        "GetEngineConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod pc_ie_amplification_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct PcIeAmplificationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PcIeAmplificationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PcIeAmplificationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PcIeAmplificationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PcIeAmplificationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Subscribe to PCIe amplification parameters
        pub async fn subscribe_pc_ie_calibration(
            &mut self,
            request: impl tonic::IntoRequest<super::PcIeCalibrationRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PcIeCalibrationUpdate>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.PCIeAmplificationService/SubscribePCIeCalibration",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.PCIeAmplificationService",
                        "SubscribePCIeCalibration",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get current PCIe configuration
        pub async fn get_pc_ie_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPcIeConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PcIeCalibrationMatrix>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.PCIeAmplificationService/GetPCIeConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.PCIeAmplificationService",
                        "GetPCIeConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Report PCIe bandwidth metrics for adaptive optimization
        pub async fn report_pc_ie_metrics(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::PcIeMetricsReport>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::PcIeOptimizationHint>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.PCIeAmplificationService/ReportPCIeMetrics",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.PCIeAmplificationService",
                        "ReportPCIeMetrics",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod telemetry_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TelemetryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TelemetryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TelemetryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TelemetryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TelemetryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Stream GPU memory status from agent to control plane
        pub async fn stream_memory_status(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::MemoryStatusUpdate,
            >,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::TelemetryAck>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.TelemetryService/StreamMemoryStatus",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.TelemetryService",
                        "StreamMemoryStatus",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Subscribe to network-wide GPU capacity updates
        pub async fn subscribe_network_capacity(
            &mut self,
            request: impl tonic::IntoRequest<super::NetworkCapacityRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::NetworkCapacityUpdate>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.TelemetryService/SubscribeNetworkCapacity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.TelemetryService",
                        "SubscribeNetworkCapacity",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Report agent health metrics
        pub async fn report_health(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::HealthMetrics>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::HealthAck>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.TelemetryService/ReportHealth",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.TelemetryService", "ReportHealth"),
                );
            self.inner.streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod allocation_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct AllocationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AllocationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AllocationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AllocationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AllocationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Allocate effective memory on the network
        pub async fn allocate_memory(
            &mut self,
            request: impl tonic::IntoRequest<super::AllocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllocationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.AllocationService/AllocateMemory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.AllocationService", "AllocateMemory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Free previously allocated memory
        pub async fn free_memory(
            &mut self,
            request: impl tonic::IntoRequest<super::FreeMemoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FreeMemoryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.AllocationService/FreeMemory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.AllocationService", "FreeMemory"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Route memory request to optimal node (load balancing)
        pub async fn route_memory_request(
            &mut self,
            request: impl tonic::IntoRequest<super::MemoryRoutingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MemoryRoutingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.AllocationService/RouteMemoryRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.AllocationService",
                        "RouteMemoryRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get current allocation status
        pub async fn get_allocation_status(
            &mut self,
            request: impl tonic::IntoRequest<super::AllocationStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllocationStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.AllocationService/GetAllocationStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.AllocationService",
                        "GetAllocationStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod operations_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct OperationsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OperationsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OperationsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OperationsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OperationsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Health check (unary)
        pub async fn health_check(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.OperationsService/HealthCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.OperationsService", "HealthCheck"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Upgrade SDK agent remotely (streaming progress)
        pub async fn upgrade_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::UpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::UpgradeProgress>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.OperationsService/UpgradeAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.OperationsService", "UpgradeAgent"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get agent system info
        pub async fn get_system_info(
            &mut self,
            request: impl tonic::IntoRequest<super::SystemInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SystemInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.OperationsService/GetSystemInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.OperationsService", "GetSystemInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restart agent service
        pub async fn restart_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RestartResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.OperationsService/RestartAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.OperationsService", "RestartAgent"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod gpu_detection_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct GpuDetectionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GpuDetectionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GpuDetectionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GpuDetectionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GpuDetectionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Register GPU and get tiered pricing based on detected hardware
        pub async fn register_gpu(
            &mut self,
            request: impl tonic::IntoRequest<super::GpuRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GpuRegistrationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.GpuDetectionService/RegisterGpu",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("cyan_flame.v1.GpuDetectionService", "RegisterGpu"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get current GPU tier configuration
        pub async fn get_gpu_tier_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GpuTierRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GpuTierResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.GpuDetectionService/GetGpuTierConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.GpuDetectionService",
                        "GetGpuTierConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all supported GPU tiers
        pub async fn list_supported_gpus(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSupportedGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSupportedGpusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.GpuDetectionService/ListSupportedGpus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.GpuDetectionService",
                        "ListSupportedGpus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod certificate_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct CertificateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CertificateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CertificateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CertificateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CertificateServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Request a new client certificate
        pub async fn request_certificate(
            &mut self,
            request: impl tonic::IntoRequest<super::CertificateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CertificateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CertificateService/RequestCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CertificateService",
                        "RequestCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Renew an existing certificate
        pub async fn renew_certificate(
            &mut self,
            request: impl tonic::IntoRequest<super::RenewCertificateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CertificateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CertificateService/RenewCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CertificateService",
                        "RenewCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Revoke a certificate
        pub async fn revoke_certificate(
            &mut self,
            request: impl tonic::IntoRequest<super::RevokeCertificateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeCertificateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CertificateService/RevokeCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CertificateService",
                        "RevokeCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get certificate status
        pub async fn get_certificate_status(
            &mut self,
            request: impl tonic::IntoRequest<super::CertificateStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CertificateStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CertificateService/GetCertificateStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CertificateService",
                        "GetCertificateStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get Certificate Revocation List
        pub async fn get_crl(
            &mut self,
            request: impl tonic::IntoRequest<super::CrlRequest>,
        ) -> std::result::Result<tonic::Response<super::CrlResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CertificateService/GetCRL",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("cyan_flame.v1.CertificateService", "GetCRL"));
            self.inner.unary(req, path, codec).await
        }
        /// OCSP responder
        pub async fn check_certificate_ocsp(
            &mut self,
            request: impl tonic::IntoRequest<super::OcspRequest>,
        ) -> std::result::Result<tonic::Response<super::OcspResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.CertificateService/CheckCertificateOCSP",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.CertificateService",
                        "CheckCertificateOCSP",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod dashboard_metrics_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct DashboardMetricsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DashboardMetricsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DashboardMetricsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DashboardMetricsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DashboardMetricsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Stream real-time system metrics
        pub async fn stream_dashboard_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::DashboardMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::DashboardMetricsUpdate>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.DashboardMetricsService/StreamDashboardMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.DashboardMetricsService",
                        "StreamDashboardMetrics",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get current connected agents
        pub async fn get_connected_agents(
            &mut self,
            request: impl tonic::IntoRequest<super::ConnectedAgentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectedAgentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.DashboardMetricsService/GetConnectedAgents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.DashboardMetricsService",
                        "GetConnectedAgents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get system summary snapshot
        pub async fn get_system_summary(
            &mut self,
            request: impl tonic::IntoRequest<super::SystemSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SystemSummaryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/cyan_flame.v1.DashboardMetricsService/GetSystemSummary",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "cyan_flame.v1.DashboardMetricsService",
                        "GetSystemSummary",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod calibration_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CalibrationServiceServer.
    #[async_trait]
    pub trait CalibrationService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SubscribeCalibrationMatrix method.
        type SubscribeCalibrationMatrixStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::CalibrationMatrixUpdate, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to calibration matrix updates (streaming - rotates every 60s)
        async fn subscribe_calibration_matrix(
            &self,
            request: tonic::Request<super::CalibrationSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeCalibrationMatrixStream>,
            tonic::Status,
        >;
        /// Get current calibration matrix (one-shot for initial sync)
        async fn get_calibration_matrix(
            &self,
            request: tonic::Request<super::GetCalibrationMatrixRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalibrationMatrix>,
            tonic::Status,
        >;
        /// Validate agent's current matrix version
        async fn validate_matrix_version(
            &self,
            request: tonic::Request<super::MatrixVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MatrixVersionResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct CalibrationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CalibrationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CalibrationServiceServer<T>
    where
        T: CalibrationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.CalibrationService/SubscribeCalibrationMatrix" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeCalibrationMatrixSvc<T: CalibrationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: CalibrationService,
                    > tonic::server::ServerStreamingService<
                        super::CalibrationSubscriptionRequest,
                    > for SubscribeCalibrationMatrixSvc<T> {
                        type Response = super::CalibrationMatrixUpdate;
                        type ResponseStream = T::SubscribeCalibrationMatrixStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::CalibrationSubscriptionRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CalibrationService>::subscribe_calibration_matrix(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeCalibrationMatrixSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CalibrationService/GetCalibrationMatrix" => {
                    #[allow(non_camel_case_types)]
                    struct GetCalibrationMatrixSvc<T: CalibrationService>(pub Arc<T>);
                    impl<
                        T: CalibrationService,
                    > tonic::server::UnaryService<super::GetCalibrationMatrixRequest>
                    for GetCalibrationMatrixSvc<T> {
                        type Response = super::CalibrationMatrix;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetCalibrationMatrixRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CalibrationService>::get_calibration_matrix(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCalibrationMatrixSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CalibrationService/ValidateMatrixVersion" => {
                    #[allow(non_camel_case_types)]
                    struct ValidateMatrixVersionSvc<T: CalibrationService>(pub Arc<T>);
                    impl<
                        T: CalibrationService,
                    > tonic::server::UnaryService<super::MatrixVersionRequest>
                    for ValidateMatrixVersionSvc<T> {
                        type Response = super::MatrixVersionResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MatrixVersionRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CalibrationService>::validate_matrix_version(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ValidateMatrixVersionSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CalibrationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.CalibrationService";
    impl<T> tonic::server::NamedService for CalibrationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod compute_calibration_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ComputeCalibrationServiceServer.
    #[async_trait]
    pub trait ComputeCalibrationService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SubscribeComputeCalibration method.
        type SubscribeComputeCalibrationStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::ComputeCalibrationUpdate,
                    tonic::Status,
                >,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to compute calibration updates (streaming - rotates every 60s)
        async fn subscribe_compute_calibration(
            &self,
            request: tonic::Request<super::ComputeCalibrationRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeComputeCalibrationStream>,
            tonic::Status,
        >;
        /// Get current compute calibration (one-shot)
        async fn get_compute_calibration(
            &self,
            request: tonic::Request<super::GetComputeCalibrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ComputeCalibrationMatrix>,
            tonic::Status,
        >;
        /// Get GPU-specific engine configuration
        async fn get_engine_config(
            &self,
            request: tonic::Request<super::EngineConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EngineConfigResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ComputeCalibrationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ComputeCalibrationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for ComputeCalibrationServiceServer<T>
    where
        T: ComputeCalibrationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.ComputeCalibrationService/SubscribeComputeCalibration" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeComputeCalibrationSvc<T: ComputeCalibrationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ComputeCalibrationService,
                    > tonic::server::ServerStreamingService<
                        super::ComputeCalibrationRequest,
                    > for SubscribeComputeCalibrationSvc<T> {
                        type Response = super::ComputeCalibrationUpdate;
                        type ResponseStream = T::SubscribeComputeCalibrationStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ComputeCalibrationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ComputeCalibrationService>::subscribe_compute_calibration(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeComputeCalibrationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.ComputeCalibrationService/GetComputeCalibration" => {
                    #[allow(non_camel_case_types)]
                    struct GetComputeCalibrationSvc<T: ComputeCalibrationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: ComputeCalibrationService,
                    > tonic::server::UnaryService<super::GetComputeCalibrationRequest>
                    for GetComputeCalibrationSvc<T> {
                        type Response = super::ComputeCalibrationMatrix;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetComputeCalibrationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ComputeCalibrationService>::get_compute_calibration(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetComputeCalibrationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.ComputeCalibrationService/GetEngineConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetEngineConfigSvc<T: ComputeCalibrationService>(pub Arc<T>);
                    impl<
                        T: ComputeCalibrationService,
                    > tonic::server::UnaryService<super::EngineConfigRequest>
                    for GetEngineConfigSvc<T> {
                        type Response = super::EngineConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::EngineConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ComputeCalibrationService>::get_engine_config(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetEngineConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ComputeCalibrationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.ComputeCalibrationService";
    impl<T> tonic::server::NamedService for ComputeCalibrationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod pc_ie_amplification_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with PcIeAmplificationServiceServer.
    #[async_trait]
    pub trait PcIeAmplificationService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the SubscribePCIeCalibration method.
        type SubscribePCIeCalibrationStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PcIeCalibrationUpdate, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to PCIe amplification parameters
        async fn subscribe_pc_ie_calibration(
            &self,
            request: tonic::Request<super::PcIeCalibrationRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribePCIeCalibrationStream>,
            tonic::Status,
        >;
        /// Get current PCIe configuration
        async fn get_pc_ie_config(
            &self,
            request: tonic::Request<super::GetPcIeConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PcIeCalibrationMatrix>,
            tonic::Status,
        >;
        /// Server streaming response type for the ReportPCIeMetrics method.
        type ReportPCIeMetricsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::PcIeOptimizationHint, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Report PCIe bandwidth metrics for adaptive optimization
        async fn report_pc_ie_metrics(
            &self,
            request: tonic::Request<tonic::Streaming<super::PcIeMetricsReport>>,
        ) -> std::result::Result<
            tonic::Response<Self::ReportPCIeMetricsStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct PcIeAmplificationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> PcIeAmplificationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for PcIeAmplificationServiceServer<T>
    where
        T: PcIeAmplificationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.PCIeAmplificationService/SubscribePCIeCalibration" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribePCIeCalibrationSvc<T: PcIeAmplificationService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: PcIeAmplificationService,
                    > tonic::server::ServerStreamingService<
                        super::PcIeCalibrationRequest,
                    > for SubscribePCIeCalibrationSvc<T> {
                        type Response = super::PcIeCalibrationUpdate;
                        type ResponseStream = T::SubscribePCIeCalibrationStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PcIeCalibrationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PcIeAmplificationService>::subscribe_pc_ie_calibration(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribePCIeCalibrationSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.PCIeAmplificationService/GetPCIeConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetPCIeConfigSvc<T: PcIeAmplificationService>(pub Arc<T>);
                    impl<
                        T: PcIeAmplificationService,
                    > tonic::server::UnaryService<super::GetPcIeConfigRequest>
                    for GetPCIeConfigSvc<T> {
                        type Response = super::PcIeCalibrationMatrix;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPcIeConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PcIeAmplificationService>::get_pc_ie_config(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPCIeConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.PCIeAmplificationService/ReportPCIeMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct ReportPCIeMetricsSvc<T: PcIeAmplificationService>(pub Arc<T>);
                    impl<
                        T: PcIeAmplificationService,
                    > tonic::server::StreamingService<super::PcIeMetricsReport>
                    for ReportPCIeMetricsSvc<T> {
                        type Response = super::PcIeOptimizationHint;
                        type ResponseStream = T::ReportPCIeMetricsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::PcIeMetricsReport>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as PcIeAmplificationService>::report_pc_ie_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReportPCIeMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for PcIeAmplificationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.PCIeAmplificationService";
    impl<T> tonic::server::NamedService for PcIeAmplificationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod telemetry_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TelemetryServiceServer.
    #[async_trait]
    pub trait TelemetryService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the StreamMemoryStatus method.
        type StreamMemoryStatusStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::TelemetryAck, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Stream GPU memory status from agent to control plane
        async fn stream_memory_status(
            &self,
            request: tonic::Request<tonic::Streaming<super::MemoryStatusUpdate>>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamMemoryStatusStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeNetworkCapacity method.
        type SubscribeNetworkCapacityStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::NetworkCapacityUpdate, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Subscribe to network-wide GPU capacity updates
        async fn subscribe_network_capacity(
            &self,
            request: tonic::Request<super::NetworkCapacityRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeNetworkCapacityStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the ReportHealth method.
        type ReportHealthStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::HealthAck, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Report agent health metrics
        async fn report_health(
            &self,
            request: tonic::Request<tonic::Streaming<super::HealthMetrics>>,
        ) -> std::result::Result<
            tonic::Response<Self::ReportHealthStream>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TelemetryServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TelemetryServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TelemetryServiceServer<T>
    where
        T: TelemetryService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.TelemetryService/StreamMemoryStatus" => {
                    #[allow(non_camel_case_types)]
                    struct StreamMemoryStatusSvc<T: TelemetryService>(pub Arc<T>);
                    impl<
                        T: TelemetryService,
                    > tonic::server::StreamingService<super::MemoryStatusUpdate>
                    for StreamMemoryStatusSvc<T> {
                        type Response = super::TelemetryAck;
                        type ResponseStream = T::StreamMemoryStatusStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::MemoryStatusUpdate>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelemetryService>::stream_memory_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamMemoryStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.TelemetryService/SubscribeNetworkCapacity" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeNetworkCapacitySvc<T: TelemetryService>(pub Arc<T>);
                    impl<
                        T: TelemetryService,
                    > tonic::server::ServerStreamingService<
                        super::NetworkCapacityRequest,
                    > for SubscribeNetworkCapacitySvc<T> {
                        type Response = super::NetworkCapacityUpdate;
                        type ResponseStream = T::SubscribeNetworkCapacityStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NetworkCapacityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelemetryService>::subscribe_network_capacity(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeNetworkCapacitySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.TelemetryService/ReportHealth" => {
                    #[allow(non_camel_case_types)]
                    struct ReportHealthSvc<T: TelemetryService>(pub Arc<T>);
                    impl<
                        T: TelemetryService,
                    > tonic::server::StreamingService<super::HealthMetrics>
                    for ReportHealthSvc<T> {
                        type Response = super::HealthAck;
                        type ResponseStream = T::ReportHealthStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::HealthMetrics>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TelemetryService>::report_health(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReportHealthSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TelemetryServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.TelemetryService";
    impl<T> tonic::server::NamedService for TelemetryServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod allocation_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AllocationServiceServer.
    #[async_trait]
    pub trait AllocationService: std::marker::Send + std::marker::Sync + 'static {
        /// Allocate effective memory on the network
        async fn allocate_memory(
            &self,
            request: tonic::Request<super::AllocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllocationResponse>,
            tonic::Status,
        >;
        /// Free previously allocated memory
        async fn free_memory(
            &self,
            request: tonic::Request<super::FreeMemoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FreeMemoryResponse>,
            tonic::Status,
        >;
        /// Route memory request to optimal node (load balancing)
        async fn route_memory_request(
            &self,
            request: tonic::Request<super::MemoryRoutingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MemoryRoutingResponse>,
            tonic::Status,
        >;
        /// Get current allocation status
        async fn get_allocation_status(
            &self,
            request: tonic::Request<super::AllocationStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AllocationStatusResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct AllocationServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AllocationServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AllocationServiceServer<T>
    where
        T: AllocationService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.AllocationService/AllocateMemory" => {
                    #[allow(non_camel_case_types)]
                    struct AllocateMemorySvc<T: AllocationService>(pub Arc<T>);
                    impl<
                        T: AllocationService,
                    > tonic::server::UnaryService<super::AllocationRequest>
                    for AllocateMemorySvc<T> {
                        type Response = super::AllocationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AllocationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AllocationService>::allocate_memory(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AllocateMemorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.AllocationService/FreeMemory" => {
                    #[allow(non_camel_case_types)]
                    struct FreeMemorySvc<T: AllocationService>(pub Arc<T>);
                    impl<
                        T: AllocationService,
                    > tonic::server::UnaryService<super::FreeMemoryRequest>
                    for FreeMemorySvc<T> {
                        type Response = super::FreeMemoryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FreeMemoryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AllocationService>::free_memory(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FreeMemorySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.AllocationService/RouteMemoryRequest" => {
                    #[allow(non_camel_case_types)]
                    struct RouteMemoryRequestSvc<T: AllocationService>(pub Arc<T>);
                    impl<
                        T: AllocationService,
                    > tonic::server::UnaryService<super::MemoryRoutingRequest>
                    for RouteMemoryRequestSvc<T> {
                        type Response = super::MemoryRoutingResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::MemoryRoutingRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AllocationService>::route_memory_request(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RouteMemoryRequestSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.AllocationService/GetAllocationStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllocationStatusSvc<T: AllocationService>(pub Arc<T>);
                    impl<
                        T: AllocationService,
                    > tonic::server::UnaryService<super::AllocationStatusRequest>
                    for GetAllocationStatusSvc<T> {
                        type Response = super::AllocationStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AllocationStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AllocationService>::get_allocation_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetAllocationStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AllocationServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.AllocationService";
    impl<T> tonic::server::NamedService for AllocationServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod operations_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with OperationsServiceServer.
    #[async_trait]
    pub trait OperationsService: std::marker::Send + std::marker::Sync + 'static {
        /// Health check (unary)
        async fn health_check(
            &self,
            request: tonic::Request<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the UpgradeAgent method.
        type UpgradeAgentStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::UpgradeProgress, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Upgrade SDK agent remotely (streaming progress)
        async fn upgrade_agent(
            &self,
            request: tonic::Request<super::UpgradeRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::UpgradeAgentStream>,
            tonic::Status,
        >;
        /// Get agent system info
        async fn get_system_info(
            &self,
            request: tonic::Request<super::SystemInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SystemInfoResponse>,
            tonic::Status,
        >;
        /// Restart agent service
        async fn restart_agent(
            &self,
            request: tonic::Request<super::RestartRequest>,
        ) -> std::result::Result<tonic::Response<super::RestartResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct OperationsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> OperationsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for OperationsServiceServer<T>
    where
        T: OperationsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.OperationsService/HealthCheck" => {
                    #[allow(non_camel_case_types)]
                    struct HealthCheckSvc<T: OperationsService>(pub Arc<T>);
                    impl<
                        T: OperationsService,
                    > tonic::server::UnaryService<super::HealthCheckRequest>
                    for HealthCheckSvc<T> {
                        type Response = super::HealthCheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HealthCheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OperationsService>::health_check(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HealthCheckSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.OperationsService/UpgradeAgent" => {
                    #[allow(non_camel_case_types)]
                    struct UpgradeAgentSvc<T: OperationsService>(pub Arc<T>);
                    impl<
                        T: OperationsService,
                    > tonic::server::ServerStreamingService<super::UpgradeRequest>
                    for UpgradeAgentSvc<T> {
                        type Response = super::UpgradeProgress;
                        type ResponseStream = T::UpgradeAgentStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpgradeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OperationsService>::upgrade_agent(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpgradeAgentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.OperationsService/GetSystemInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetSystemInfoSvc<T: OperationsService>(pub Arc<T>);
                    impl<
                        T: OperationsService,
                    > tonic::server::UnaryService<super::SystemInfoRequest>
                    for GetSystemInfoSvc<T> {
                        type Response = super::SystemInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SystemInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OperationsService>::get_system_info(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSystemInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.OperationsService/RestartAgent" => {
                    #[allow(non_camel_case_types)]
                    struct RestartAgentSvc<T: OperationsService>(pub Arc<T>);
                    impl<
                        T: OperationsService,
                    > tonic::server::UnaryService<super::RestartRequest>
                    for RestartAgentSvc<T> {
                        type Response = super::RestartResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestartRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as OperationsService>::restart_agent(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestartAgentSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for OperationsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.OperationsService";
    impl<T> tonic::server::NamedService for OperationsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod gpu_detection_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with GpuDetectionServiceServer.
    #[async_trait]
    pub trait GpuDetectionService: std::marker::Send + std::marker::Sync + 'static {
        /// Register GPU and get tiered pricing based on detected hardware
        async fn register_gpu(
            &self,
            request: tonic::Request<super::GpuRegistrationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GpuRegistrationResponse>,
            tonic::Status,
        >;
        /// Get current GPU tier configuration
        async fn get_gpu_tier_config(
            &self,
            request: tonic::Request<super::GpuTierRequest>,
        ) -> std::result::Result<tonic::Response<super::GpuTierResponse>, tonic::Status>;
        /// List all supported GPU tiers
        async fn list_supported_gpus(
            &self,
            request: tonic::Request<super::ListSupportedGpusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSupportedGpusResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct GpuDetectionServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> GpuDetectionServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for GpuDetectionServiceServer<T>
    where
        T: GpuDetectionService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.GpuDetectionService/RegisterGpu" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterGpuSvc<T: GpuDetectionService>(pub Arc<T>);
                    impl<
                        T: GpuDetectionService,
                    > tonic::server::UnaryService<super::GpuRegistrationRequest>
                    for RegisterGpuSvc<T> {
                        type Response = super::GpuRegistrationResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GpuRegistrationRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GpuDetectionService>::register_gpu(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterGpuSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.GpuDetectionService/GetGpuTierConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetGpuTierConfigSvc<T: GpuDetectionService>(pub Arc<T>);
                    impl<
                        T: GpuDetectionService,
                    > tonic::server::UnaryService<super::GpuTierRequest>
                    for GetGpuTierConfigSvc<T> {
                        type Response = super::GpuTierResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GpuTierRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GpuDetectionService>::get_gpu_tier_config(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetGpuTierConfigSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.GpuDetectionService/ListSupportedGpus" => {
                    #[allow(non_camel_case_types)]
                    struct ListSupportedGpusSvc<T: GpuDetectionService>(pub Arc<T>);
                    impl<
                        T: GpuDetectionService,
                    > tonic::server::UnaryService<super::ListSupportedGpusRequest>
                    for ListSupportedGpusSvc<T> {
                        type Response = super::ListSupportedGpusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListSupportedGpusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as GpuDetectionService>::list_supported_gpus(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListSupportedGpusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for GpuDetectionServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.GpuDetectionService";
    impl<T> tonic::server::NamedService for GpuDetectionServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod certificate_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with CertificateServiceServer.
    #[async_trait]
    pub trait CertificateService: std::marker::Send + std::marker::Sync + 'static {
        /// Request a new client certificate
        async fn request_certificate(
            &self,
            request: tonic::Request<super::CertificateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CertificateResponse>,
            tonic::Status,
        >;
        /// Renew an existing certificate
        async fn renew_certificate(
            &self,
            request: tonic::Request<super::RenewCertificateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CertificateResponse>,
            tonic::Status,
        >;
        /// Revoke a certificate
        async fn revoke_certificate(
            &self,
            request: tonic::Request<super::RevokeCertificateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RevokeCertificateResponse>,
            tonic::Status,
        >;
        /// Get certificate status
        async fn get_certificate_status(
            &self,
            request: tonic::Request<super::CertificateStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CertificateStatusResponse>,
            tonic::Status,
        >;
        /// Get Certificate Revocation List
        async fn get_crl(
            &self,
            request: tonic::Request<super::CrlRequest>,
        ) -> std::result::Result<tonic::Response<super::CrlResponse>, tonic::Status>;
        /// OCSP responder
        async fn check_certificate_ocsp(
            &self,
            request: tonic::Request<super::OcspRequest>,
        ) -> std::result::Result<tonic::Response<super::OcspResponse>, tonic::Status>;
    }
    #[derive(Debug)]
    pub struct CertificateServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> CertificateServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for CertificateServiceServer<T>
    where
        T: CertificateService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.CertificateService/RequestCertificate" => {
                    #[allow(non_camel_case_types)]
                    struct RequestCertificateSvc<T: CertificateService>(pub Arc<T>);
                    impl<
                        T: CertificateService,
                    > tonic::server::UnaryService<super::CertificateRequest>
                    for RequestCertificateSvc<T> {
                        type Response = super::CertificateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CertificateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CertificateService>::request_certificate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RequestCertificateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CertificateService/RenewCertificate" => {
                    #[allow(non_camel_case_types)]
                    struct RenewCertificateSvc<T: CertificateService>(pub Arc<T>);
                    impl<
                        T: CertificateService,
                    > tonic::server::UnaryService<super::RenewCertificateRequest>
                    for RenewCertificateSvc<T> {
                        type Response = super::CertificateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RenewCertificateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CertificateService>::renew_certificate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RenewCertificateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CertificateService/RevokeCertificate" => {
                    #[allow(non_camel_case_types)]
                    struct RevokeCertificateSvc<T: CertificateService>(pub Arc<T>);
                    impl<
                        T: CertificateService,
                    > tonic::server::UnaryService<super::RevokeCertificateRequest>
                    for RevokeCertificateSvc<T> {
                        type Response = super::RevokeCertificateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RevokeCertificateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CertificateService>::revoke_certificate(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RevokeCertificateSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CertificateService/GetCertificateStatus" => {
                    #[allow(non_camel_case_types)]
                    struct GetCertificateStatusSvc<T: CertificateService>(pub Arc<T>);
                    impl<
                        T: CertificateService,
                    > tonic::server::UnaryService<super::CertificateStatusRequest>
                    for GetCertificateStatusSvc<T> {
                        type Response = super::CertificateStatusResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CertificateStatusRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CertificateService>::get_certificate_status(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCertificateStatusSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CertificateService/GetCRL" => {
                    #[allow(non_camel_case_types)]
                    struct GetCRLSvc<T: CertificateService>(pub Arc<T>);
                    impl<
                        T: CertificateService,
                    > tonic::server::UnaryService<super::CrlRequest> for GetCRLSvc<T> {
                        type Response = super::CrlResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CrlRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CertificateService>::get_crl(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetCRLSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.CertificateService/CheckCertificateOCSP" => {
                    #[allow(non_camel_case_types)]
                    struct CheckCertificateOCSPSvc<T: CertificateService>(pub Arc<T>);
                    impl<
                        T: CertificateService,
                    > tonic::server::UnaryService<super::OcspRequest>
                    for CheckCertificateOCSPSvc<T> {
                        type Response = super::OcspResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::OcspRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as CertificateService>::check_certificate_ocsp(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckCertificateOCSPSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for CertificateServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.CertificateService";
    impl<T> tonic::server::NamedService for CertificateServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated server implementations.
pub mod dashboard_metrics_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with DashboardMetricsServiceServer.
    #[async_trait]
    pub trait DashboardMetricsService: std::marker::Send + std::marker::Sync + 'static {
        /// Server streaming response type for the StreamDashboardMetrics method.
        type StreamDashboardMetricsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::DashboardMetricsUpdate, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Stream real-time system metrics
        async fn stream_dashboard_metrics(
            &self,
            request: tonic::Request<super::DashboardMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::StreamDashboardMetricsStream>,
            tonic::Status,
        >;
        /// Get current connected agents
        async fn get_connected_agents(
            &self,
            request: tonic::Request<super::ConnectedAgentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectedAgentsResponse>,
            tonic::Status,
        >;
        /// Get system summary snapshot
        async fn get_system_summary(
            &self,
            request: tonic::Request<super::SystemSummaryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SystemSummaryResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct DashboardMetricsServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> DashboardMetricsServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for DashboardMetricsServiceServer<T>
    where
        T: DashboardMetricsService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/cyan_flame.v1.DashboardMetricsService/StreamDashboardMetrics" => {
                    #[allow(non_camel_case_types)]
                    struct StreamDashboardMetricsSvc<T: DashboardMetricsService>(
                        pub Arc<T>,
                    );
                    impl<
                        T: DashboardMetricsService,
                    > tonic::server::ServerStreamingService<
                        super::DashboardMetricsRequest,
                    > for StreamDashboardMetricsSvc<T> {
                        type Response = super::DashboardMetricsUpdate;
                        type ResponseStream = T::StreamDashboardMetricsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DashboardMetricsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as DashboardMetricsService>::stream_dashboard_metrics(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StreamDashboardMetricsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.DashboardMetricsService/GetConnectedAgents" => {
                    #[allow(non_camel_case_types)]
                    struct GetConnectedAgentsSvc<T: DashboardMetricsService>(pub Arc<T>);
                    impl<
                        T: DashboardMetricsService,
                    > tonic::server::UnaryService<super::ConnectedAgentsRequest>
                    for GetConnectedAgentsSvc<T> {
                        type Response = super::ConnectedAgentsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ConnectedAgentsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as DashboardMetricsService>::get_connected_agents(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConnectedAgentsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/cyan_flame.v1.DashboardMetricsService/GetSystemSummary" => {
                    #[allow(non_camel_case_types)]
                    struct GetSystemSummarySvc<T: DashboardMetricsService>(pub Arc<T>);
                    impl<
                        T: DashboardMetricsService,
                    > tonic::server::UnaryService<super::SystemSummaryRequest>
                    for GetSystemSummarySvc<T> {
                        type Response = super::SystemSummaryResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SystemSummaryRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as DashboardMetricsService>::get_system_summary(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSystemSummarySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(empty_body());
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for DashboardMetricsServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "cyan_flame.v1.DashboardMetricsService";
    impl<T> tonic::server::NamedService for DashboardMetricsServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
